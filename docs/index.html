<html>
  <head>
    <title>VARELA</title>
    <style>
      body {
        background-color: black;
        color: white;
      }
      code:not(.language-diff) {
        background-color: white;
        color: black;
        display: inline-block;
      }
      code.language-diff {
        background-color: while;
        color: green;
      }
    </style>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js"],
        "HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"] },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], displayMath: [ ["$$","$$"], ["\\[", "\\]"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno" },
        TeX: { noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } } },
        messageStyle: "none"
      });
    </script>
    <script
      type="text/javascript"
      src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js"
    ></script>
  </head>
  <body>
    <h1>Varela: Minimum Vertex Cover Solver</h1>
    <p>
      <img
        src="varela.jpg"
        alt="Honoring the Memory of Felix Varela y Morales (Cuban Catholic priest and independence leader)"
      />
    </p>
    <p>
      This work builds upon
      <a
        href="https://www.researchgate.net/publication/388728980_Approximation_Algorithms_for_NP-hard_Problems"
        >Approximation Algorithms for NP-hard Problems</a
      >.
    </p>
    <hr />
    <h1>The Minimum Vertex Cover Problem</h1>
    <p>
      The <strong>Minimum Vertex Cover (MVC)</strong> problem is a classic
      optimization problem in computer science and graph theory. It involves
      finding the smallest set of vertices in a graph that
      <strong>covers</strong> all edges, meaning at least one endpoint of every
      edge is included in the set.
    </p>
    <h2>Formal Definition</h2>
    <p>
      Given an undirected graph $G = (V, E)$, a <strong>vertex cover</strong> is
      a subset $V' \subseteq V$ such that for every edge $(u, v) \in E$, at
      least one of $u$ or $v$ belongs to $V'$. The MVC problem seeks the vertex
      cover with the smallest cardinality.
    </p>
    <h2>Importance and Applications</h2>
    <ul>
      <li>
        <strong>Theoretical Significance:</strong> MVC is a well-known NP-hard
        problem, central to complexity theory.
      </li>
      <li>
        <strong>Practical Applications:</strong>
        <ul>
          <li>
            <strong>Network Security:</strong> Identifying critical nodes to
            disrupt connections.
          </li>
          <li>
            <strong>Bioinformatics:</strong> Analyzing gene regulatory networks.
          </li>
          <li>
            <strong>Wireless Sensor Networks:</strong> Optimizing sensor
            coverage.
          </li>
        </ul>
      </li>
    </ul>
    <h2>Related Problems</h2>
    <ul>
      <li>
        <strong>Maximum Independent Set:</strong> The complement of a vertex
        cover.
      </li>
      <li><strong>Set Cover Problem:</strong> A generalization of MVC.</li>
    </ul>
    <hr />
    <h2>Problem Statement</h2>
    <p>Input: A Boolean Adjacency Matrix $M$.</p>
    <p>Answer: Find a Minimum Vertex Cover.</p>
    <h3>Example Instance: 5 x 5 matrix</h3>
    <table>
      <thead>
        <tr>
          <th></th>
          <th>c0</th>
          <th>c1</th>
          <th>c2</th>
          <th>c3</th>
          <th>c4</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>r0</strong></td>
          <td>0</td>
          <td>0</td>
          <td>1</td>
          <td>0</td>
          <td>1</td>
        </tr>
        <tr>
          <td><strong>r1</strong></td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>1</td>
          <td>0</td>
        </tr>
        <tr>
          <td><strong>r2</strong></td>
          <td>1</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
          <td>1</td>
        </tr>
        <tr>
          <td><strong>r3</strong></td>
          <td>0</td>
          <td>1</td>
          <td>0</td>
          <td>0</td>
          <td>0</td>
        </tr>
        <tr>
          <td><strong>r4</strong></td>
          <td>1</td>
          <td>0</td>
          <td>1</td>
          <td>0</td>
          <td>0</td>
        </tr>
      </tbody>
    </table>
    <p>
      A matrix is represented in a text file using the following string
      representation:
    </p>
    <pre><code>00101
00010
10001
01000
10100
</code></pre>
    <p>
      This represents a 5x5 matrix where each line corresponds to a row, and '1'
      indicates a connection or presence of an element, while '0' indicates its
      absence.
    </p>
    <p><em>Example Solution:</em></p>
    <p>
      Vertex Cover Found <code>0, 1, 4</code>: Nodes <code>0</code>,
      <code>1</code>, and <code>4</code> constitute an optimal solution.
    </p>
    <hr />
    <h1>Our Algorithm - Polynomial Runtime</h1>
    <h2>Algorithm Overview</h2>
    <ol>
      <li><strong>Input</strong>: Adjacency matrix of graph G</li>
      <li>
        <strong>Create Edge Graph</strong>:
        <ul>
          <li>Nodes represent edges of G</li>
          <li>Connect nodes if edges share a vertex</li>
        </ul>
      </li>
      <li><strong>Find Minimum Edge Cover</strong> in edge graph</li>
      <li>
        <strong>Extract Vertex Cover</strong>:
        <ul>
          <li>Add common vertices from edge cover</li>
        </ul>
      </li>
      <li>
        <strong>Handle Isolated Edges</strong>:
        <ul>
          <li>Add vertices for uncovered edges</li>
        </ul>
      </li>
      <li><strong>Remove Redundant Vertices</strong></li>
      <li><strong>Output</strong>: Approximate minimum vertex cover</li>
    </ol>
    <p>Key Features:</p>
    <ul>
      <li>Polynomial-time complexity: O($|E|^3$)</li>
      <li>Approximation ratio: ≤ 3/2 for large graphs</li>
      <li>Suitable for large, sparse graphs</li>
    </ul>
    <h2>Correctness</h2>
    <ol>
      <li>
        <p><strong>Edge Graph Construction</strong></p>
        <ul>
          <li>Preserves edge relationships of original graph</li>
        </ul>
      </li>
      <li>
        <p><strong>Minimum Edge Cover</strong></p>
        <ul>
          <li>Ensures every edge in edge graph is covered</li>
        </ul>
      </li>
      <li>
        <p><strong>Vertex Cover Extraction</strong></p>
        <ul>
          <li>Guarantees at least one endpoint of each edge is in cover</li>
        </ul>
      </li>
      <li>
        <p><strong>Isolated Edge Handling</strong></p>
        <ul>
          <li>Covers any remaining uncovered edges</li>
        </ul>
      </li>
      <li>
        <p><strong>Redundancy Removal</strong></p>
        <ul>
          <li>Optimizes cover size while maintaining validity</li>
        </ul>
      </li>
    </ol>
    <p>Correctness Guarantee:</p>
    <ul>
      <li>Every edge in original graph has at least one endpoint in cover</li>
      <li>Resulting set is a valid, approximate minimum vertex cover</li>
    </ul>
    <p>Approximation Quality:</p>
    <ul>
      <li>Achieves ≤ 3/2 approximation ratio for large graphs</li>
      <li>Trade-off between accuracy and polynomial-time efficiency</li>
    </ul>
    <h2>Runtime Analysis</h2>
    <p>
      This section analyzes the runtime and space complexity of the given vertex
      cover approximation algorithm.
    </p>
    <h3>Time Complexity Breakdown</h3>
    <ol>
      <li>
        <p><strong>Input Processing and Graph Creation:</strong> $O(|E|)$</p>
        <ul>
          <li>$|E|$ represents the number of edges in the input graph.</li>
          <li>
            This step involves converting the sparse matrix representation to a
            NetworkX graph, which iterates through the non-zero entries (edges).
          </li>
        </ul>
      </li>
      <li>
        <p><strong>Edge Graph Construction:</strong> $O(|E| \Delta)$</p>
        <ul>
          <li>
            $\Delta$ represents the maximum degree of any vertex in the graph.
          </li>
          <li>
            For each edge in the original graph, we examine its endpoints'
            neighbors to create corresponding edges in the edge graph. The
            number of neighbors is bounded by $\Delta$.
          </li>
        </ul>
      </li>
      <li>
        <p><strong>Minimum Edge Cover Computation:</strong> $O(|E|^3)$</p>
        <ul>
          <li>
            This step utilizes the <code>nx.min_edge_cover()</code> function.
            The complexity relates to the number of <em>nodes</em> in the edge
            graph (which is $|E|$). The complexity is therefore $O(|E|^3)$.
          </li>
        </ul>
      </li>
      <li>
        <p><strong>Vertex Cover Extraction:</strong> $O(|E|)$</p>
        <ul>
          <li>
            This step iterates through the edges in the computed minimum edge
            cover, which is bounded by the number of edges in the original
            graph.
          </li>
        </ul>
      </li>
      <li>
        <p><strong>Isolated Edge Handling:</strong> $O(|E|)$</p>
        <ul>
          <li>
            We iterate through all edges in the original graph to handle any
            isolated edges.
          </li>
        </ul>
      </li>
      <li>
        <p>
          <strong>Redundancy Removal:</strong> $O(k |E|)$, or $O(|E|^2)$ in the
          worst case.
        </p>
        <ul>
          <li>
            $k$ is the size of the vertex cover. In the worst-case, the size of
            the vertex cover can be $O(|E|)$, so the overall time complexity is
            $O(|E|^2)$.
          </li>
          <li>
            For each vertex in the (potentially large) vertex cover, we check if
            its removal still leaves a valid cover. This check involves
            examining all edges.
          </li>
        </ul>
      </li>
    </ol>
    <h3>Overall Complexity</h3>
    <ul>
      <li>
        <strong>Time Complexity:</strong> $O(|E|^3)$ (dominated by the minimum
        edge cover computation).
      </li>
      <li>
        <strong>Space Complexity:</strong> $O(|V| + |E| + |E|\Delta)$. In the
        worst-case scenario (dense graphs where $E = O(|V|^2)$ and $\Delta =
        O(|V|)$), this becomes $O(|V|^3)$.
      </li>
    </ul>
    <h3>Key Observations</h3>
    <ul>
      <li>
        This algorithm provides an <em>approximation</em> of the minimum vertex
        cover, trading accuracy for a polynomial runtime.
      </li>
      <li>
        The practical runtime performance can often be significantly better than
        the worst-case theoretical bound, especially for sparse graphs.
      </li>
      <li>
        This approach is suitable for large graphs where computing the
        <em>exact</em> minimum vertex cover is computationally infeasible.
      </li>
    </ul>
    <hr />
    <h1>Compile and Environment</h1>
    <h2>Prerequisites</h2>
    <ul>
      <li>Python ≥ 3.10</li>
    </ul>
    <h2>Installation</h2>
    <pre><code class="language-bash">pip install varela
</code></pre>
    <h2>Execution</h2>
    <ol>
      <li>
        <p>Clone the repository:</p>
        <pre><code class="language-bash">git clone https://github.com/frankvegadelgado/varela.git
cd varela
</code></pre>
      </li>
      <li>
        <p>Run the script:</p>
        <pre><code class="language-bash">approx -i ./benchmarks/testMatrix1.txt
</code></pre>
        <p>
          utilizing the <code>approx</code> command provided by Varela's Library
          to execute the Boolean adjacency matrix
          <code>varela\benchmarks\testMatrix1.txt</code>. The file
          <code>testMatrix1.txt</code> represents the example described herein.
          We also support <code>.xz</code>, <code>.lzma</code>,
          <code>.bz2</code>, and <code>.bzip2</code> compressed
          <code>.txt</code> files.
        </p>
        <p><strong>Example Output:</strong></p>
        <pre><code>testMatrix1.txt: Vertex Cover Found 0, 1, 4
</code></pre>
        <p>This indicates nodes <code>0, 1, 4</code> form a vertex cover.</p>
      </li>
    </ol>
    <hr />
    <h2>Vertex Cover Size</h2>
    <p>Use the <code>-c</code> flag to count the nodes in the vertex cover:</p>
    <pre><code class="language-bash">approx -i ./benchmarks/testMatrix2.txt -c
</code></pre>
    <p><strong>Output:</strong></p>
    <pre><code>testMatrix2.txt: Vertex Cover Size 5
</code></pre>
    <hr />
    <h1>Command Options</h1>
    <p>Display help and options:</p>
    <pre><code class="language-bash">approx -h
</code></pre>
    <p><strong>Output:</strong></p>
    <pre><code class="language-bash">usage: approx [-h] -i INPUTFILE [-a] [-b] [-c] [-v] [-l] [--version]

Estimating the Minimum Vertex Cover with an approximation factor of ≤ 3/2 for an undirected graph encoded as a Boolean adjacency matrix stored in a file.

options:
  -h, --help            show this help message and exit
  -i INPUTFILE, --inputFile INPUTFILE
                        input file path
  -a, --approximation   enable comparison with a polynomial-time approximation approach within a factor of 2
  -b, --bruteForce      enable comparison with the exponential-time brute-force approach
  -c, --count           calculate the size of the vertex cover
  -v, --verbose         enable verbose output
  -l, --log             enable file logging
  --version             show program's version number and exit
</code></pre>
    <hr />
    <h1>Testing Application</h1>
    <p>
      A command-line utility named <code>test_approx</code> is provided for
      evaluating the Algorithm using randomly generated, large sparse matrices.
      It supports the following options:
    </p>
    <pre><code class="language-bash">usage: test_approx [-h] -d DIMENSION [-n NUM_TESTS] [-s SPARSITY] [-a] [-b] [-c] [-w] [-v] [-l] [--version]

The Varela Testing Application.

options:
  -h, --help            show this help message and exit
  -d DIMENSION, --dimension DIMENSION
                        an integer specifying the dimensions of the square matrices
  -n NUM_TESTS, --num_tests NUM_TESTS
                        an integer specifying the number of tests to run
  -s SPARSITY, --sparsity SPARSITY
                        sparsity of the matrices (0.0 for dense, close to 1.0 for very sparse)
  -a, --approximation   enable comparison with a polynomial-time approximation approach within a factor of 2
  -b, --bruteForce      enable comparison with the exponential-time brute-force approach
  -c, --count           calculate the size of the vertex cover
  -w, --write           write the generated random matrix to a file in the current directory
  -v, --verbose         enable verbose output
  -l, --log             enable file logging
  --version             show program's version number and exit
</code></pre>
    <hr />
    <h1>Code</h1>
    <ul>
      <li>Python implementation by <strong>Frank Vega</strong>.</li>
    </ul>
    <hr />
    <h1>Complexity</h1>
    <pre><code class="language-diff">+ This result contradicts the Unique Games Conjecture, suggesting that many optimization problems may admit better solutions, revolutionizing theoretical computer science.
</code></pre>
    <hr />
    <h1>License</h1>
    <ul>
      <li>MIT License.</li>
    </ul>
  </body>
</html>
